---
title: "999_dev"
author: "Jagadeesh Puvvula"
date: "2025-01-01"
output: pdf_document
---

```{r}
getRasterValueInRange <- function(dataframe, input_folder_name, batch_size = 8) {
    # Print initial debugging info
    cat("Function started with parameters:\n")
    cat(sprintf("Input folder: %s\n", input_folder_name))
    cat(sprintf("Number of rows in dataframe: %d\n", nrow(dataframe)))
    cat("Sample of input data:\n")
    print(head(dataframe))
    
    # Initialize an empty list to store extracted values for all observations
    all_raster_values <- vector("list", length = nrow(dataframe))
    
    # Calculate number of batches
    n_batches <- ceiling(nrow(dataframe) / batch_size)
    
    # Create a local copy of input_folder_name for parallel processing
    folder_path <- input_folder_name
    
    for(batch in 1:n_batches) {
        # Calculate batch indices
        start_idx <- (batch - 1) * batch_size + 1
        end_idx <- min(batch * batch_size, nrow(dataframe))
        
        cat(sprintf("\nProcessing batch %d of %d (rows %d to %d)\n", 
                    batch, n_batches, start_idx, end_idx))
        
        # Setup parallel processing for this batch
        cl <- makeCluster(min(batch_size, detectCores()))
        registerDoParallel(cl)
        
        # Process the batch
        batch_results <- foreach(i = start_idx:end_idx, 
                                 .packages = c("raster"),
                                 .errorhandling = 'pass') %dopar% {
                                     tryCatch({
                                         cat(sprintf("\n=== Starting processing for row %d ===\n", i))
                                         
                                         # Extract and validate date information
                                         cat("Extracting date information...\n")
                                         start_date <- try(as.Date(dataframe[i, "start_date"]), silent = TRUE)
                                         end_date <- try(as.Date(dataframe[i, "end_date"]), silent = TRUE)
                                         
                                         cat(sprintf("Start date: %s, End date: %s\n", 
                                                     format(start_date), format(end_date)))
                                         
                                         # Extract and validate coordinate information
                                         cat("Extracting coordinate information...\n")
                                         latitude <- try(as.numeric(dataframe[i, "lat"]), silent = TRUE)
                                         longitude <- try(as.numeric(dataframe[i, "long"]), silent = TRUE)
                                         
                                         cat(sprintf("Latitude: %f, Longitude: %f\n", 
                                                     latitude, longitude))
                                         
                                         # Validate inputs with detailed error messages
                                         if (inherits(latitude, "try-error") || inherits(longitude, "try-error")) {
                                             stop("Invalid coordinates format")
                                         }
                                         if (inherits(start_date, "try-error") || inherits(end_date, "try-error")) {
                                             stop("Invalid date format")
                                         }
                                         if (is.na(start_date) || is.na(end_date)) {
                                             stop("Dates contain NA values")
                                         }
                                         if (end_date < start_date) {
                                             stop("End date is before start date")
                                         }
                                         
                                         # Initialize an empty list to store daily values
                                         daily_values <- list()
                                         
                                         # Iterate through each day in the date range
                                         current_date <- start_date
                                         while (current_date <= end_date) {
                                             date_str <- format(current_date, "%Y%m%d")
                                             cat(sprintf("\nProcessing date: %s\n", date_str))
                                             
                                             # Construct and verify file pattern
                                             file_pattern <- sprintf("USHAP_PM2.5_D1K_%s_V1\\.tif$", date_str)
                                             cat(sprintf("Looking for files matching pattern: %s\n", file_pattern))
                                             
                                             # List files matching the current date
                                             matching_files <- list.files(
                                                 path = folder_path,  # Use the local copy of the path
                                                 pattern = file_pattern, 
                                                 full.names = TRUE, 
                                                 recursive = TRUE
                                             )
                                             
                                             cat(sprintf("Found %d matching files\n", length(matching_files)))
                                             if(length(matching_files) > 0) {
                                                 cat("Matching files:\n")
                                                 print(matching_files)
                                             }
                                             
                                             # Initialize value for this day
                                             daily_value <- NA
                                             
                                             # Loop through each matching file
                                             for (file in matching_files) {
                                                 cat(sprintf("Processing file: %s\n", file))
                                                 
                                                 if (!file.exists(file)) {
                                                     cat(sprintf("File does not exist: %s\n", file))
                                                     next
                                                 }
                                                 
                                                 # Load the raster file
                                                 cat("Loading raster file...\n")
                                                 raster_data <- try(raster(file), silent = TRUE)
                                                 
                                                 if (inherits(raster_data, "try-error")) {
                                                     cat(sprintf("Failed to load raster: %s\n", 
                                                                 attr(raster_data, "condition")$message))
                                                     next
                                                 }
                                                 
                                                 if (inherits(raster_data, "RasterLayer")) {
                                                     cat("Successfully loaded raster. Extracting value...\n")
                                                     # Create points from coordinates
                                                     point <- cbind(longitude, latitude)
                                                     
                                                     # Extract the raster value
                                                     value <- try(extract(raster_data, point), silent = TRUE)
                                                     
                                                     if (!inherits(value, "try-error") && !is.na(value) && !is.nan(value)) {
                                                         daily_value <- value
                                                         cat(sprintf("Successfully extracted value: %f\n", value))
                                                     } else {
                                                         cat("Failed to extract value or value is NA/NaN\n")
                                                     }
                                                     
                                                     # Clean up
                                                     rm(raster_data)
                                                     gc()
                                                 }
                                             }
                                             
                                             # Store the daily value
                                             daily_values[[date_str]] <- sprintf("%.2f", daily_value)
                                             cat(sprintf("Stored value for date %s: %s\n", 
                                                         date_str, daily_values[[date_str]]))
                                             
                                             # Increment date
                                             current_date <- as.Date(current_date + 1)
                                         }
                                         
                                         cat(sprintf("Successfully completed processing for row %d\n", i))
                                         return(daily_values)
                                         
                                     }, error = function(e) {
                                         cat(sprintf("ERROR in row %d: %s\n", i, e$message))
                                         return(NULL)
                                     })
                                 }
        
        # Stop the cluster for this batch
        stopCluster(cl)
        
        # Store batch results in the main results list
        batch_indices <- start_idx:end_idx
        all_raster_values[batch_indices] <- batch_results
        
        # Check for failures in this batch with detailed information
        null_indices <- which(sapply(batch_results, is.null))
        if (length(null_indices) > 0) {
            actual_indices <- batch_indices[null_indices]
            warning(sprintf("Batch %d: Failed processing for rows: %s", 
                            batch, paste(actual_indices, collapse = ", ")))
        }
    }
    
    # Final status report
    cat("\nProcessing completed.\n")
    cat(sprintf("Total rows processed: %d\n", nrow(dataframe)))
    cat(sprintf("Successful rows: %d\n", sum(!sapply(all_raster_values, is.null))))
    cat(sprintf("Failed rows: %d\n", sum(sapply(all_raster_values, is.null))))
    
    # Append all results to the dataframe
    dataframe$raster_value <- all_raster_values
    
    return(dataframe)
}

```

#MWAS
```{r}
mwas_lm_loop <- function(feature_table, exp_cov_data, output_folder, mwas_file_name, cutoff_file_name, exposures, covar, fdr_cutoff) {
  result_list <- list() # create an empty list to store results

  for (variable in exposures) {
    current_results <- data.frame(matrix(nrow = nrow(feature_table), ncol = 4)) # create a new data frame for each variable
    names(current_results) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
    for (i in 1:nrow(feature_table)) {
      metabolite <- unlist(feature_table[i, -c(1)]) # store the ith metabolite in a new vector
      formula_str <- paste("metabolite ~", variable, "+", paste(covar, collapse = " + "))
      current_results[i, ] <- summary(lm(formula_str, data = cbind(metabolite, exp_cov_data)))$coefficients[2, c(1:4)] # store regression results for the ith metabolite
    }
    current_results$FDR <- p.adjust(current_results[[4]], method = "fdr") # fdr adjustment
    current_results <- cbind(feature_table[c(1)], current_results) # add mz and time
    current_results$Variable <- variable
    result_list[[variable]] <- current_results # add current results to list
  }

  PAH_MWAS_result <- do.call(rbind, result_list) # combine all results into one data frame

  # Calculate beta_dir variable
  PAH_MWAS_result$beta_dir <- case_when(
    PAH_MWAS_result$FDR < fdr_cutoff & PAH_MWAS_result$Estimate > 0 ~ "positive-significant",
    PAH_MWAS_result$FDR < fdr_cutoff & PAH_MWAS_result$Estimate < 0 ~ "negative-significant",
    PAH_MWAS_result$FDR > fdr_cutoff & PAH_MWAS_result$Estimate > 0 ~ "positive-non_significant",
    PAH_MWAS_result$FDR > fdr_cutoff & PAH_MWAS_result$Estimate < 0 ~ "negative-non_significant", TRUE ~ NA_character_)

  # Save final result to a file
  output_file <- file.path(output_folder, mwas_file_name)
  write.csv(PAH_MWAS_result, file = output_file, row.names = FALSE)

  return(PAH_MWAS_result)
}
```

#birth weight z score
```{r}
olsen_ref <- tribble(
  ~sex, ~ga, ~mean_bw, ~sd_bw,
  "M", 23, 622, 74,
  "M", 24, 689, 96,
  "M", 25, 777, 116,
  "M", 26, 888, 145,
  "M", 27, 1001, 170,
  "M", 28, 1138, 203,
  "M", 29, 1277, 218,
  "M", 30, 1435, 261,
  "M", 31, 1633, 275,
  "M", 32, 1823, 306,
  "M", 33, 2058, 341,
  "M", 34, 2288, 364,
  "M", 35, 2529, 433,
  "M", 36, 2798, 498,
  "M", 37, 3058, 518,
  "M", 38, 3319, 527,
  "M", 39, 3476, 498,
  "M", 40, 3582, 493,
  "M", 41, 3691, 518,
  
  "F", 23, 587, 80,
  "F", 24, 649, 89,
  "F", 25, 738, 121,
  "F", 26, 822, 143,
  "F", 27, 934, 168,
  "F", 28, 1058, 203,
  "F", 29, 1199, 226,
  "F", 30, 1376, 246,
  "F", 31, 1548, 271,
  "F", 32, 1730, 300,
  "F", 33, 1960, 328,
  "F", 34, 2194, 357,
  "F", 35, 2420, 440,
  "F", 36, 2675, 514,
  "F", 37, 2946, 551,
  "F", 38, 3184, 512,
  "F", 39, 3342, 489,
  "F", 40, 3461, 465,
  "F", 41, 3546, 477
)
```

#linear reg
```{r}
lm_func <- function(dependent_vars, independent_vars, data, covariates, include_sex = TRUE, include_cohort = TRUE, conf_level = 0.95) {
  # Create empty lists to store results
  dependent_list <- list()
  independent_list <- list()
  sex_level_list <- list()
  cohort_level_list <- list()
  coef_list <- list()
  p_value_list <- list()
  ci_lower_list <- list()
  ci_upper_list <- list()
  n_obs_list <- list()  # NEW: for observation count
  
  if ("sex" %in% colnames(data)) {
    sex_present <- TRUE
  } else {
    sex_present <- FALSE
    include_sex <- FALSE
  }
  
  if ("cohort" %in% colnames(data)) {
    cohort_present <- TRUE
  } else {
    cohort_present <- FALSE
    include_cohort <- FALSE
  }
  
  sex_levels <- if (include_sex) c("all", "Female", "Male") else "all"
  cohort_levels <- if (include_cohort) c("all", "home", "mirec") else "all"
  
  for (sex_level in sex_levels) {
    if (sex_level == "all" || !sex_present) {
      sex_data <- data
      sex_formula <- ""
    } else {
      sex_data <- subset(data, sex == sex_level)
      sex_data <- droplevels(sex_data)
      sex_formula <- ""
    }
    
    for (cohort_level in cohort_levels) {
      if (cohort_level == "all" || !cohort_present) {
        cohort_data <- sex_data
        cohort_formula <- ""
      } else if (cohort_level == "home") {
        cohort_data <- subset(sex_data, cohort == "1")
        cohort_data <- droplevels(cohort_data)
        cohort_formula <- ""
      } else if (cohort_level == "mirec") {
        cohort_data <- subset(sex_data, cohort == "2")
        cohort_data <- droplevels(cohort_data)
        cohort_formula <- "+city"
      } else {
        stop("Invalid cohort level")
      }
      
      # Loop through all combinations of dependent and independent variables
      for (i in 1:length(dependent_vars)) {
        for (j in 1:length(independent_vars)) {
          # Create the covariates formula dynamically based on the covariates argument
          covariate_formula <- paste(covariates, collapse = " + ")
          
          # Run linear regression with dynamic covariates
          formula <- as.formula(paste(dependent_vars[i], "~", independent_vars[j], "+", covariate_formula, sex_formula, cohort_formula))
          
          # Fit model with na.action = na.exclude to handle NAs
          model <- lm(formula, data = cohort_data, na.action = na.omit)
          
          # Calculate confidence interval
          ci <- confint(model, parm = independent_vars[j], level = conf_level)
          
          # Store results in lists
          dependent_list[[length(dependent_list) + 1]] <- dependent_vars[i]
          independent_list[[length(independent_list) + 1]] <- independent_vars[j]
          sex_level_list[[length(sex_level_list) + 1]] <- sex_level
          cohort_level_list[[length(cohort_level_list) + 1]] <- cohort_level
          coef_list[[length(coef_list) + 1]] <- coef(model)[independent_vars[j]]
          p_value_list[[length(p_value_list) + 1]] <- summary(model)$coefficients[independent_vars[j], 4]
          ci_lower_list[[length(ci_lower_list) + 1]] <- ci[1]
          ci_upper_list[[length(ci_upper_list) + 1]] <- ci[2]
          n_obs_list[[length(n_obs_list) + 1]] <- nobs(model)  # NEW: number of observations
        }
      }
    }
  }
  
  # Create a dataframe with results
  results <- data.frame(
    dependent_variable = unlist(dependent_list),
    independent_variable = unlist(independent_list),
    sex_level = unlist(sex_level_list),
    cohort_level = unlist(cohort_level_list),
    coefficient = unlist(coef_list),
    p_value = unlist(p_value_list),
    ci_lower = unlist(ci_lower_list),
    ci_upper = unlist(ci_upper_list),
    n_obs = unlist(n_obs_list)  # NEW: add observation count
  )
  
  # Add FDR-adjusted p-values (Benjamini-Hochberg method)
  # Calculate FDR within each sex_level and cohort_level combination
  results <- results |>
    group_by(sex_level, cohort_level) |>
    mutate(p_value_fdr = p.adjust(p_value, method = "fdr")) |>
    ungroup()
  
  # Return the dataframe
  return(results)
}
```

