---
title: "999_dev"
author: "Jagadeesh Puvvula"
date: "2025-01-01"
output: pdf_document
---

```{r}
getRasterValueInRange <- function(dataframe, input_folder_name, batch_size = 8) {
    # Print initial debugging info
    cat("Function started with parameters:\n")
    cat(sprintf("Input folder: %s\n", input_folder_name))
    cat(sprintf("Number of rows in dataframe: %d\n", nrow(dataframe)))
    cat("Sample of input data:\n")
    print(head(dataframe))
    
    # Initialize an empty list to store extracted values for all observations
    all_raster_values <- vector("list", length = nrow(dataframe))
    
    # Calculate number of batches
    n_batches <- ceiling(nrow(dataframe) / batch_size)
    
    # Create a local copy of input_folder_name for parallel processing
    folder_path <- input_folder_name
    
    for(batch in 1:n_batches) {
        # Calculate batch indices
        start_idx <- (batch - 1) * batch_size + 1
        end_idx <- min(batch * batch_size, nrow(dataframe))
        
        cat(sprintf("\nProcessing batch %d of %d (rows %d to %d)\n", 
                    batch, n_batches, start_idx, end_idx))
        
        # Setup parallel processing for this batch
        cl <- makeCluster(min(batch_size, detectCores()))
        registerDoParallel(cl)
        
        # Process the batch
        batch_results <- foreach(i = start_idx:end_idx, 
                                 .packages = c("raster"),
                                 .errorhandling = 'pass') %dopar% {
                                     tryCatch({
                                         cat(sprintf("\n=== Starting processing for row %d ===\n", i))
                                         
                                         # Extract and validate date information
                                         cat("Extracting date information...\n")
                                         start_date <- try(as.Date(dataframe[i, "start_date"]), silent = TRUE)
                                         end_date <- try(as.Date(dataframe[i, "end_date"]), silent = TRUE)
                                         
                                         cat(sprintf("Start date: %s, End date: %s\n", 
                                                     format(start_date), format(end_date)))
                                         
                                         # Extract and validate coordinate information
                                         cat("Extracting coordinate information...\n")
                                         latitude <- try(as.numeric(dataframe[i, "lat"]), silent = TRUE)
                                         longitude <- try(as.numeric(dataframe[i, "long"]), silent = TRUE)
                                         
                                         cat(sprintf("Latitude: %f, Longitude: %f\n", 
                                                     latitude, longitude))
                                         
                                         # Validate inputs with detailed error messages
                                         if (inherits(latitude, "try-error") || inherits(longitude, "try-error")) {
                                             stop("Invalid coordinates format")
                                         }
                                         if (inherits(start_date, "try-error") || inherits(end_date, "try-error")) {
                                             stop("Invalid date format")
                                         }
                                         if (is.na(start_date) || is.na(end_date)) {
                                             stop("Dates contain NA values")
                                         }
                                         if (end_date < start_date) {
                                             stop("End date is before start date")
                                         }
                                         
                                         # Initialize an empty list to store daily values
                                         daily_values <- list()
                                         
                                         # Iterate through each day in the date range
                                         current_date <- start_date
                                         while (current_date <= end_date) {
                                             date_str <- format(current_date, "%Y%m%d")
                                             cat(sprintf("\nProcessing date: %s\n", date_str))
                                             
                                             # Construct and verify file pattern
                                             file_pattern <- sprintf("USHAP_PM2.5_D1K_%s_V1\\.tif$", date_str)
                                             cat(sprintf("Looking for files matching pattern: %s\n", file_pattern))
                                             
                                             # List files matching the current date
                                             matching_files <- list.files(
                                                 path = folder_path,  # Use the local copy of the path
                                                 pattern = file_pattern, 
                                                 full.names = TRUE, 
                                                 recursive = TRUE
                                             )
                                             
                                             cat(sprintf("Found %d matching files\n", length(matching_files)))
                                             if(length(matching_files) > 0) {
                                                 cat("Matching files:\n")
                                                 print(matching_files)
                                             }
                                             
                                             # Initialize value for this day
                                             daily_value <- NA
                                             
                                             # Loop through each matching file
                                             for (file in matching_files) {
                                                 cat(sprintf("Processing file: %s\n", file))
                                                 
                                                 if (!file.exists(file)) {
                                                     cat(sprintf("File does not exist: %s\n", file))
                                                     next
                                                 }
                                                 
                                                 # Load the raster file
                                                 cat("Loading raster file...\n")
                                                 raster_data <- try(raster(file), silent = TRUE)
                                                 
                                                 if (inherits(raster_data, "try-error")) {
                                                     cat(sprintf("Failed to load raster: %s\n", 
                                                                 attr(raster_data, "condition")$message))
                                                     next
                                                 }
                                                 
                                                 if (inherits(raster_data, "RasterLayer")) {
                                                     cat("Successfully loaded raster. Extracting value...\n")
                                                     # Create points from coordinates
                                                     point <- cbind(longitude, latitude)
                                                     
                                                     # Extract the raster value
                                                     value <- try(extract(raster_data, point), silent = TRUE)
                                                     
                                                     if (!inherits(value, "try-error") && !is.na(value) && !is.nan(value)) {
                                                         daily_value <- value
                                                         cat(sprintf("Successfully extracted value: %f\n", value))
                                                     } else {
                                                         cat("Failed to extract value or value is NA/NaN\n")
                                                     }
                                                     
                                                     # Clean up
                                                     rm(raster_data)
                                                     gc()
                                                 }
                                             }
                                             
                                             # Store the daily value
                                             daily_values[[date_str]] <- sprintf("%.2f", daily_value)
                                             cat(sprintf("Stored value for date %s: %s\n", 
                                                         date_str, daily_values[[date_str]]))
                                             
                                             # Increment date
                                             current_date <- as.Date(current_date + 1)
                                         }
                                         
                                         cat(sprintf("Successfully completed processing for row %d\n", i))
                                         return(daily_values)
                                         
                                     }, error = function(e) {
                                         cat(sprintf("ERROR in row %d: %s\n", i, e$message))
                                         return(NULL)
                                     })
                                 }
        
        # Stop the cluster for this batch
        stopCluster(cl)
        
        # Store batch results in the main results list
        batch_indices <- start_idx:end_idx
        all_raster_values[batch_indices] <- batch_results
        
        # Check for failures in this batch with detailed information
        null_indices <- which(sapply(batch_results, is.null))
        if (length(null_indices) > 0) {
            actual_indices <- batch_indices[null_indices]
            warning(sprintf("Batch %d: Failed processing for rows: %s", 
                            batch, paste(actual_indices, collapse = ", ")))
        }
    }
    
    # Final status report
    cat("\nProcessing completed.\n")
    cat(sprintf("Total rows processed: %d\n", nrow(dataframe)))
    cat(sprintf("Successful rows: %d\n", sum(!sapply(all_raster_values, is.null))))
    cat(sprintf("Failed rows: %d\n", sum(sapply(all_raster_values, is.null))))
    
    # Append all results to the dataframe
    dataframe$raster_value <- all_raster_values
    
    return(dataframe)
}

```

#MWAS
```{r}
mwas_lm_loop <- function(feature_table, exp_cov_data, output_folder, mwas_file_name, cutoff_file_name, exposures, covar, fdr_cutoff, sex_var = NULL, analyze_by_sex = FALSE, participant_id_col = "participant_id") {
  
  # ===== QC STEP 1: Validate input parameters =====
  if (analyze_by_sex && is.null(sex_var)) {
    stop("sex_var must be provided when analyze_by_sex is TRUE")
  }
  
  if (!participant_id_col %in% names(exp_cov_data)) {
    stop(paste("participant_id column '", participant_id_col, "' not found in exp_cov_data", sep = ""))
  }
  
  # ===== QC STEP 2: Validate dimensions =====
  message(paste("QC: feature_table dimensions:", nrow(feature_table), "metabolites x", ncol(feature_table) - 1, "samples"))
  message(paste("QC: exp_cov_data dimensions:", nrow(exp_cov_data), "participants x", ncol(exp_cov_data), "variables"))
  
  # ===== QC STEP 3: Extract and match participant IDs =====
  feature_table_ids <- names(feature_table)[2:ncol(feature_table)]
  exp_cov_ids <- exp_cov_data[[participant_id_col]]
  
  message(paste("QC: feature_table has", length(feature_table_ids), "participants"))
  message(paste("QC: exp_cov_data has", length(exp_cov_ids), "participants"))
  
  # Check for overlapping IDs
  matching_ids <- intersect(feature_table_ids, exp_cov_ids)
  message(paste("QC: Found", length(matching_ids), "matching participants"))
  
  if (length(matching_ids) == 0) {
    stop("No matching participant IDs found between feature_table and exp_cov_data")
  }
  
  if (length(matching_ids) < length(exp_cov_ids) * 0.8) {
    warning(paste("Warning: Less than 80% of participants matched. Matching rate:", 
                  round(length(matching_ids) / length(exp_cov_ids) * 100, 1), "%"))
  }
  
  # ===== QC STEP 4: Reorder and subset data to match =====
  exp_cov_data <- exp_cov_data[match(matching_ids, exp_cov_ids), ]
  feature_table <- feature_table[, c(1, match(matching_ids, feature_table_ids) + 1)]
  
  if (!all(names(feature_table)[2:ncol(feature_table)] == exp_cov_data[[participant_id_col]])) {
    stop("Failed to properly match participant IDs between datasets")
  }
  
  message(paste("QC: Successfully matched and reordered", nrow(exp_cov_data), "participants"))
  
  # ===== QC STEP 5: Check for missing values =====
  missing_exp_cov <- colSums(is.na(exp_cov_data))
  if (any(missing_exp_cov > 0)) {
    message("QC: Missing values in exp_cov_data:")
    print(missing_exp_cov[missing_exp_cov > 0])
  }
  
  missing_features <- rowSums(is.na(feature_table[, -1]))
  if (any(missing_features > 0)) {
    message(paste("QC: Found", sum(missing_features > 0), "metabolites with missing values"))
  }
  
  # ===== QC STEP 6: Validate exposures and covariates exist =====
  missing_exposures <- exposures[!exposures %in% names(exp_cov_data)]
  if (length(missing_exposures) > 0) {
    stop(paste("Missing exposures:", paste(missing_exposures, collapse = ", ")))
  }
  
  missing_covar <- covar[!covar %in% names(exp_cov_data)]
  if (length(missing_covar) > 0) {
    stop(paste("Missing covariates:", paste(missing_covar, collapse = ", ")))
  }
  
  message(paste("QC: All", length(exposures), "exposures and", length(covar), "covariates found"))
  
  # ===== QC STEP 7: Validate sex_var if needed =====
  if (analyze_by_sex) {
    if (!sex_var %in% names(exp_cov_data)) {
      stop(paste("sex_var '", sex_var, "' not found in exp_cov_data", sep = ""))
    }
    sex_summary <- table(exp_cov_data[[sex_var]], useNA = "ifany")
    message("QC: Sex variable distribution:")
    print(sex_summary)
  }
  
  result_list <- list()
  
  # Helper function to run analysis
  run_analysis <- function(current_feature_table, current_exp_cov_data, current_covar, analysis_name, sex_group_label) {
    message(paste("=== Analyzing:", analysis_name, "(n =", nrow(current_exp_cov_data), ") ==="))
    
    for (variable in exposures) {
      current_results <- data.frame(matrix(nrow = nrow(current_feature_table), ncol = 4))
      names(current_results) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
      
      for (i in 1:nrow(current_feature_table)) {
        metabolite <- unlist(current_feature_table[i, -c(1)])
        
        # Create formula
        covar_str <- if (length(current_covar) > 0) paste("+", paste(current_covar, collapse = " + ")) else ""
        formula_str <- as.formula(paste("metabolite ~", variable, covar_str))
        
        # Create model data
        model_data <- cbind(metabolite = metabolite, current_exp_cov_data)
        
        tryCatch({
          model <- lm(formula_str, data = model_data)
          current_results[i, ] <- summary(model)$coefficients[2, c(1:4)]
        }, error = function(e) {
          current_results[i, ] <<- NA
          warning(paste("Model fitting failed for metabolite", i, "and variable", variable))
        })
      }
      
      current_results$FDR <- p.adjust(current_results[[4]], method = "fdr")
      current_results <- cbind(current_feature_table[c(1)], current_results)
      current_results$Variable <- variable
      
      if (analyze_by_sex) {
        current_results$Sex <- sex_group_label
      }
      
      result_key <- paste(variable, sex_group_label, sep = "_")
      result_list[[result_key]] <<- current_results
    }
  }
  
  # ===== STEP 1: OVERALL ANALYSIS (all observations with sex_var as covariate only if analyzing by sex) =====
  message("\n>>> STEP 1: OVERALL ANALYSIS <<<")
  
  # When performing sex-stratified analysis, include sex_var as a covariate in the overall model to adjust for sex effects
  if (analyze_by_sex) {
    overall_covar <- unique(c(covar, sex_var))
    overall_sex_label <- "overall"
  } else {
    overall_covar <- covar
    overall_sex_label <- "all"
  }
  
  run_analysis(
    current_feature_table = feature_table,
    current_exp_cov_data = exp_cov_data,
    current_covar = overall_covar,
    analysis_name = "Overall (all observations)",
    sex_group_label = overall_sex_label
  )
  
  # ===== STEP 2: SEX-STRATIFIED ANALYSIS (if analyze_by_sex = TRUE) =====
  if (analyze_by_sex) {
    message("\n>>> STEP 2: SEX-STRATIFIED ANALYSIS <<<")
    sex_levels <- unique(exp_cov_data[[sex_var]])
    sex_levels <- sex_levels[!is.na(sex_levels)]
    sex_levels <- sort(sex_levels)
    
    for (sex_group in sex_levels) {
      group_indices <- which(exp_cov_data[[sex_var]] == sex_group)
      current_exp_cov_data <- exp_cov_data[group_indices, ]
      current_feature_table <- feature_table[, c(1, group_indices + 1)]
      current_covar <- covar[covar != sex_var]  # Remove sex_var for stratified analysis
      
      run_analysis(
        current_feature_table = current_feature_table,
        current_exp_cov_data = current_exp_cov_data,
        current_covar = current_covar,
        analysis_name = paste(sex_group, "only"),
        sex_group_label = sex_group
      )
    }
  }
  
  MWAS_result <- do.call(rbind, result_list)
  rownames(MWAS_result) <- NULL
  
  # Calculate beta_dir variable
  MWAS_result$beta_dir <- dplyr::case_when(
    MWAS_result$FDR < fdr_cutoff & MWAS_result$Estimate > 0 ~ "positive-significant",
    MWAS_result$FDR < fdr_cutoff & MWAS_result$Estimate < 0 ~ "negative-significant",
    MWAS_result$FDR >= fdr_cutoff & MWAS_result$Estimate > 0 ~ "positive-non_significant",
    MWAS_result$FDR >= fdr_cutoff & MWAS_result$Estimate < 0 ~ "negative-non_significant",
    TRUE ~ NA_character_
  )
  
  # Save final result to a file
  output_file <- file.path(output_folder, mwas_file_name)
  write.csv(MWAS_result, file = output_file, row.names = FALSE)
  
  message("\n>>> ANALYSIS COMPLETE <<<")
  message(paste("Results saved to:", output_file))
  
  return(MWAS_result)
}
```

#birth weight z score
```{r}
olsen_ref <- tribble(
  ~sex, ~ga, ~mean_bw, ~sd_bw,
  "M", 23, 622, 74,
  "M", 24, 689, 96,
  "M", 25, 777, 116,
  "M", 26, 888, 145,
  "M", 27, 1001, 170,
  "M", 28, 1138, 203,
  "M", 29, 1277, 218,
  "M", 30, 1435, 261,
  "M", 31, 1633, 275,
  "M", 32, 1823, 306,
  "M", 33, 2058, 341,
  "M", 34, 2288, 364,
  "M", 35, 2529, 433,
  "M", 36, 2798, 498,
  "M", 37, 3058, 518,
  "M", 38, 3319, 527,
  "M", 39, 3476, 498,
  "M", 40, 3582, 493,
  "M", 41, 3691, 518,
  
  "F", 23, 587, 80,
  "F", 24, 649, 89,
  "F", 25, 738, 121,
  "F", 26, 822, 143,
  "F", 27, 934, 168,
  "F", 28, 1058, 203,
  "F", 29, 1199, 226,
  "F", 30, 1376, 246,
  "F", 31, 1548, 271,
  "F", 32, 1730, 300,
  "F", 33, 1960, 328,
  "F", 34, 2194, 357,
  "F", 35, 2420, 440,
  "F", 36, 2675, 514,
  "F", 37, 2946, 551,
  "F", 38, 3184, 512,
  "F", 39, 3342, 489,
  "F", 40, 3461, 465,
  "F", 41, 3546, 477
)
```

#linear reg
```{r}
lm_func <- function(dependent_vars, independent_vars, data, covariates, include_sex = TRUE, include_cohort = TRUE, conf_level = 0.95) {
  # Create empty lists to store results
  dependent_list <- list()
  independent_list <- list()
  sex_level_list <- list()
  cohort_level_list <- list()
  coef_list <- list()
  p_value_list <- list()
  ci_lower_list <- list()
  ci_upper_list <- list()
  n_obs_list <- list()  # NEW: for observation count
  
  if ("sex" %in% colnames(data)) {
    sex_present <- TRUE
  } else {
    sex_present <- FALSE
    include_sex <- FALSE
  }
  
  if ("cohort" %in% colnames(data)) {
    cohort_present <- TRUE
  } else {
    cohort_present <- FALSE
    include_cohort <- FALSE
  }
  
  sex_levels <- if (include_sex) c("all", "Female", "Male") else "all"
  cohort_levels <- if (include_cohort) c("all", "home", "mirec") else "all"
  
  for (sex_level in sex_levels) {
    if (sex_level == "all" || !sex_present) {
      sex_data <- data
      sex_formula <- ""
    } else {
      sex_data <- subset(data, sex == sex_level)
      sex_data <- droplevels(sex_data)
      sex_formula <- ""
    }
    
    for (cohort_level in cohort_levels) {
      if (cohort_level == "all" || !cohort_present) {
        cohort_data <- sex_data
        cohort_formula <- ""
      } else if (cohort_level == "home") {
        cohort_data <- subset(sex_data, cohort == "1")
        cohort_data <- droplevels(cohort_data)
        cohort_formula <- ""
      } else if (cohort_level == "mirec") {
        cohort_data <- subset(sex_data, cohort == "2")
        cohort_data <- droplevels(cohort_data)
        cohort_formula <- "+city"
      } else {
        stop("Invalid cohort level")
      }
      
      # Loop through all combinations of dependent and independent variables
      for (i in 1:length(dependent_vars)) {
        for (j in 1:length(independent_vars)) {
          # Create the covariates formula dynamically based on the covariates argument
          covariate_formula <- paste(covariates, collapse = " + ")
          
          # Run linear regression with dynamic covariates
          formula <- as.formula(paste(dependent_vars[i], "~", independent_vars[j], "+", covariate_formula, sex_formula, cohort_formula))
          
          # Fit model with na.action = na.exclude to handle NAs
          model <- lm(formula, data = cohort_data, na.action = na.omit)
          
          # Calculate confidence interval
          ci <- confint(model, parm = independent_vars[j], level = conf_level)
          
          # Store results in lists
          dependent_list[[length(dependent_list) + 1]] <- dependent_vars[i]
          independent_list[[length(independent_list) + 1]] <- independent_vars[j]
          sex_level_list[[length(sex_level_list) + 1]] <- sex_level
          cohort_level_list[[length(cohort_level_list) + 1]] <- cohort_level
          coef_list[[length(coef_list) + 1]] <- coef(model)[independent_vars[j]]
          p_value_list[[length(p_value_list) + 1]] <- summary(model)$coefficients[independent_vars[j], 4]
          ci_lower_list[[length(ci_lower_list) + 1]] <- ci[1]
          ci_upper_list[[length(ci_upper_list) + 1]] <- ci[2]
          n_obs_list[[length(n_obs_list) + 1]] <- nobs(model)  # NEW: number of observations
        }
      }
    }
  }
  
  # Create a dataframe with results
  results <- data.frame(
    dependent_variable = unlist(dependent_list),
    independent_variable = unlist(independent_list),
    sex_level = unlist(sex_level_list),
    cohort_level = unlist(cohort_level_list),
    coefficient = unlist(coef_list),
    p_value = unlist(p_value_list),
    ci_lower = unlist(ci_lower_list),
    ci_upper = unlist(ci_upper_list),
    n_obs = unlist(n_obs_list)  # NEW: add observation count
  )
  
  # Add FDR-adjusted p-values (Benjamini-Hochberg method)
  # Calculate FDR within each sex_level and cohort_level combination
  results <- results |>
    group_by(sex_level, cohort_level) |>
    mutate(p_value_fdr = p.adjust(p_value, method = "fdr")) |>
    ungroup()
  
  # Return the dataframe
  return(results)
}
```

